{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@opengsn/contracts/src/ERC2771Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-inline-assembly\npragma solidity >=0.6.9;\n\nimport \"./interfaces/IERC2771Recipient.sol\";\n\n/**\n * @title The ERC-2771 Recipient Base Abstract Class - Implementation\n *\n * @notice Note that this contract was called `BaseRelayRecipient` in the previous revision of the GSN.\n *\n * @notice A base contract to be inherited by any contract that want to receive relayed transactions.\n *\n * @notice A subclass must use `_msgSender()` instead of `msg.sender`.\n */\nabstract contract ERC2771Recipient is IERC2771Recipient {\n\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address private _trustedForwarder;\n\n    /**\n     * :warning: **Warning** :warning: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\n     * @notice Method is not a required method to allow Recipients to trust multiple Forwarders. Not recommended yet.\n     * @return forwarder The address of the Forwarder contract that is being used.\n     */\n    function getTrustedForwarder() public virtual view returns (address forwarder){\n        return _trustedForwarder;\n    }\n\n    function _setTrustedForwarder(address _forwarder) internal {\n        _trustedForwarder = _forwarder;\n    }\n\n    /// @inheritdoc IERC2771Recipient\n    function isTrustedForwarder(address forwarder) public virtual override view returns(bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    /// @inheritdoc IERC2771Recipient\n    function _msgSender() internal override virtual view returns (address ret) {\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            ret = msg.sender;\n        }\n    }\n\n    /// @inheritdoc IERC2771Recipient\n    function _msgData() internal override virtual view returns (bytes calldata ret) {\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\n            return msg.data[0:msg.data.length-20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "@opengsn/contracts/src/interfaces/IERC2771Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n/**\n * @title The ERC-2771 Recipient Base Abstract Class - Declarations\n *\n * @notice A contract must implement this interface in order to support relayed transaction.\n *\n * @notice It is recommended that your contract inherits from the ERC2771Recipient contract.\n */\nabstract contract IERC2771Recipient {\n\n    /**\n     * :warning: **Warning** :warning: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\n     * @param forwarder The address of the Forwarder contract that is being used.\n     * @return isTrustedForwarder `true` if the Forwarder is trusted to forward relayed transactions by this Recipient.\n     */\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\n\n    /**\n     * @notice Use this method the contract anywhere instead of msg.sender to support relayed transactions.\n     * @return sender The real sender of this call.\n     * For a call that came through the Forwarder the real sender is extracted from the last 20 bytes of the `msg.data`.\n     * Otherwise simply returns `msg.sender`.\n     */\n    function _msgSender() internal virtual view returns (address);\n\n    /**\n     * @notice Use this method in the contract instead of `msg.data` when difference matters (hashing, signature, etc.)\n     * @return data The real `msg.data` of this call.\n     * For a call that came through the Forwarder, the real sender address was appended as the last 20 bytes\n     * of the `msg.data` - so this method will strip those 20 bytes off.\n     * Otherwise (if the call was made directly and not through the forwarder) simply returns `msg.data`.\n     */\n    function _msgData() internal virtual view returns (bytes calldata);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/EnergyToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Energy_Token is ERC20 {\n    /*\n        Initial Supply is 50 ,- 50 WEI\n        Initial supply 50e18\n        or, 50*10**18\n    */\n    constructor() ERC20(\"Enery Token\", \"UNIT\") {}\n}\n"
    },
    "contracts/EnergyTrade.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./EnergyToken.sol\";\r\nimport \"./PriceConverter.sol\";\r\nimport \"./MultiSig.sol\";\r\n\r\ncontract EnergyTrade is Energy_Token, PriceConverter, MultiSig {\r\n    /*************Global Variables************/\r\n\r\n    address escrowAccount; //Address of the Deployed Smart Contract\r\n    uint256 EnergyUnitPrice_usd;\r\n    uint256 EnergyUnitPrice_matic;\r\n\r\n    /****************Constructor************/\r\n\r\n    constructor(\r\n        address forwarder,\r\n        address[] memory _owners,\r\n        uint256 _required\r\n    ) MultiSig(forwarder, _owners, _required) {\r\n        escrowAccount = address(this);\r\n    }\r\n\r\n    /****************Events**************************************/\r\n\r\n    event EnergyListed(\r\n        uint256 indexed sellerID,\r\n        uint256 unitEnergyPriceUSD,\r\n        uint256 unitEnergyPriceMatic,\r\n        uint256 listedEnergyToken\r\n    );\r\n\r\n    event EnergyBought(\r\n        uint256 indexed sellerID,\r\n        uint256 indexed buyerID,\r\n        uint256 indexed unitEnergyPriceUSD,\r\n        uint256 unitEnergyPriceMatic,\r\n        uint256 boughtEnergyToken\r\n    );\r\n\r\n    //Overriden GSN functions to resolve naming conflicts\r\n\r\n    function _msgSender() internal view override(Context, ERC2771Recipient) returns (address) {\r\n        return ERC2771Recipient._msgSender();\r\n    }\r\n\r\n    function _msgData() internal view override(Context, ERC2771Recipient) returns (bytes calldata) {\r\n        return ERC2771Recipient._msgData();\r\n    }\r\n\r\n    /***************General View Functions***********************/\r\n\r\n    function viewEscrowBalance() public view returns (uint256, uint256) {\r\n        return (address(this).balance, balanceOf(escrowAccount));\r\n    }\r\n\r\n    function viewMaticBalance() public view returns (uint256) {\r\n        return msg.sender.balance;\r\n    }\r\n\r\n    function viewEnergyBalance() public view returns (uint256) {\r\n        return balanceOf(msg.sender);\r\n    }\r\n\r\n    /********************TRADING FUNCTION FOR PROSUMERS**********************************/\r\n\r\n    /*-------------------Producer--------------------------------------------------------------*/\r\n\r\n    //--> 1. Set Energy Unit Price for 1 Unit of Energy\r\n    function setUnitPrice(uint256 price) private onlyProsumer returns (uint256) {\r\n        /* Take Price input as 1e16 */\r\n\r\n        EnergyUnitPrice_usd = price;\r\n        uint256 latestMaticPrice = uint(getLatestPrice());\r\n        EnergyUnitPrice_matic = (price / latestMaticPrice) * 1e10;\r\n        /*------- 1e16/1e8 * 1e10 = 1e18 ----- ------------------*/\r\n\r\n        return EnergyUnitPrice_matic;\r\n    }\r\n\r\n    //--> 2. List Energy for Sale\r\n    function listEnergy(\r\n        uint256 unitEnergyPrice,\r\n        uint256 excessEnergyToken\r\n    ) public onlyProsumer isNotSuspended returns (uint256) {\r\n        require(\r\n            ApprovedProsumers[prosumerID[msg.sender] - 1]._stakedEnergyBalance == 0,\r\n            \"You have Already Staked Energy\"\r\n        );\r\n\r\n        uint256 ad_placerID = prosumerID[msg.sender];\r\n\r\n        ApprovedProsumers[ad_placerID - 1]._energyUnitPriceUSD = unitEnergyPrice;\r\n        ApprovedProsumers[ad_placerID - 1]._energyUnitPriceMatic = (setUnitPrice(unitEnergyPrice));\r\n        ApprovedProsumers[ad_placerID - 1]._stakedEnergyBalance = excessEnergyToken;\r\n\r\n        transfer(escrowAccount, excessEnergyToken);\r\n\r\n        emit EnergyListed(\r\n            ad_placerID,\r\n            ApprovedProsumers[ad_placerID - 1]._energyUnitPriceUSD,\r\n            ApprovedProsumers[ad_placerID - 1]._energyUnitPriceMatic,\r\n            excessEnergyToken\r\n        );\r\n\r\n        return ad_placerID;\r\n    }\r\n\r\n    //--> 3. Set Unit Price for 1 Unit of Energy in Matic\r\n    function mySetUnitPrice_Matic() public view onlyProsumer returns (uint256) {\r\n        return ApprovedProsumers[prosumerID[msg.sender] - 1]._energyUnitPriceMatic;\r\n    }\r\n\r\n    //--> 4. Set Unit Price for 1 Unit of Energy in USD\r\n    function mySetUnitPrice_USD() public view onlyProsumer returns (uint256) {\r\n        return ApprovedProsumers[prosumerID[msg.sender] - 1]._energyUnitPriceUSD;\r\n    }\r\n\r\n    //--> 5. Mint Energy Token\r\n    function produceEnergy(uint256 energyProduced) public onlyProsumer isNotSuspended {\r\n        _mint(msg.sender, energyProduced);\r\n    }\r\n\r\n    //--> 6. Burn Energy Token\r\n    function burnEnergy(uint256 energyBurned) public onlyProsumer isNotSuspended {\r\n        _burn(msg.sender, energyBurned);\r\n    }\r\n\r\n    /*-------------------Consumer--------------------------------------------------------------*/\r\n\r\n    //--> 1. Buy Energy\r\n    function buyEnergy(\r\n        uint256 producerID,\r\n        uint256 energy_need\r\n    ) public payable onlyProsumer isNotSuspended {\r\n        uint256 MinPayableAmount = ApprovedProsumers[producerID - 1]._energyUnitPriceMatic *\r\n            energy_need;\r\n        require(msg.value >= MinPayableAmount, \"Didn't send enough Matic!\");\r\n        require(\r\n            energy_need <= ApprovedProsumers[producerID - 1]._stakedEnergyBalance,\r\n            \"Selected Producer do have enough Enough Energy Balance\"\r\n        );\r\n\r\n        // State Change Before Transfer to avoid Re-entrancy Attack\r\n        ApprovedProsumers[producerID - 1]._stakedEnergyBalance =\r\n            ApprovedProsumers[producerID - 1]._stakedEnergyBalance -\r\n            energy_need;\r\n\r\n        //Transfer Energy to Consumer\r\n        _transfer(escrowAccount, msg.sender, energy_need);\r\n\r\n        //Transfer Matic to Producer\r\n        (bool callSuccess, ) = payable(prosumerAddress[producerID]).call{value: MinPayableAmount}(\r\n            \"\"\r\n        );\r\n\r\n        require(callSuccess, \"call failed\");\r\n\r\n        emit EnergyBought(\r\n            producerID,\r\n            prosumerID[msg.sender],\r\n            ApprovedProsumers[producerID - 1]._energyUnitPriceUSD,\r\n            ApprovedProsumers[producerID - 1]._energyUnitPriceMatic,\r\n            energy_need\r\n        );\r\n    }\r\n\r\n    /****************Modifiers************/\r\n\r\n    modifier onlyProsumer() {\r\n        require(isProsumer[msg.sender], \"Not Prosumer\");\r\n        _;\r\n    }\r\n\r\n    modifier isNotSuspended() {\r\n        require(!ApprovedProsumers[prosumerID[msg.sender] - 1]._suspended, \"You are Suspended\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/MultiSig.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.7;\nimport \"@opengsn/contracts/src/ERC2771Recipient.sol\";\n\n//GSN ENABLED CONTRACT\n\ncontract MultiSig is ERC2771Recipient {\n    /*************Global Variables************/\n\n    uint256 public required;\n    uint256 public regFee;\n\n    address[] public owners;\n\n    mapping(address => bool) public isOwner;\n    mapping(address => mapping(address => bool)) public approved; //address1 = unapprovedProsumer address, address2 = address Of Owner, bool\n    mapping(address => mapping(address => bool)) public disapproved; //address1 = unapprovedProsumer address, address2 = address Of Owner, bool\n    mapping(address => mapping(address => bool)) public suspended; //address1 = unapprovedProsumer address, address2 = address Of Owner, bool\n    mapping(address => mapping(address => bool)) public unSuspended; //address1 = unapprovedProsumer address, address2 = address Of Owner, bool\n\n    /*-------Prosumer Variables-------------------------*/\n    struct prosumer {\n        uint256 _prosumerID;\n        address _address;\n        uint256 _aadharId;\n        bool _approved;\n        bool _suspended;\n        uint256 _energyUnitPriceUSD;\n        uint256 _energyUnitPriceMatic;\n        uint256 _stakedEnergyBalance;\n    }\n\n    prosumer[] public ApprovedProsumers;\n    prosumer[] public unApprovedProsumers;\n\n    mapping(address => bool) public isProsumer;\n    mapping(uint256 => address) public prosumerAddress;\n    mapping(address => uint256) public prosumerID;\n\n    //Prosumer Stats\n    mapping(address => uint256) public approvalCount;\n    mapping(address => uint256) public disapprovalCount;\n    mapping(address => uint256) public suspensionCount;\n    mapping(address => uint256) public unSuspensionCount;\n\n    /****************Complain**************************************/\n    struct Complain {\n        uint256 _complainID;\n        uint256 _complainant;\n        uint256 _accused;\n        string _complain;\n        bool _resolved;\n    }\n\n    uint256 public complainCount;\n    uint256 public maxComplains = 10;\n    Complain[] public complains;\n\n    /****************Constructor************/\n    constructor(address forwarder, address[] memory _owners, uint _required) {\n        //Set the trusted forwarder\n        _setTrustedForwarder(forwarder);\n\n        //We will pass multiple owners & set a particular requirement number of apporvals needed\n        require(_owners.length > 0, \"Owners Required\");\n        require(_required > 0 && _required <= _owners.length, \"Invalid required number of owners\");\n\n        for (uint i; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"invalid owner\");\n            require(!isOwner[owner], \"Owner is not unique\");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        required = _required;\n    }\n\n    string public versionRecipient = \"3.0.0\";\n\n    // Request for Registration as Prosumer\n\n    /**Unverified User Function***/\n\n    //Internal Function\n    function isRequested() private view returns (bool) {\n        for (uint256 i = 0; i < unApprovedProsumers.length; i++) {\n            if (msg.sender == unApprovedProsumers[i]._address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-->1. Register as Prosumer\n    function req_Registration(uint256 _aadharNo) public payable {\n        require(!isOwner[msg.sender], \"You are an Owner\");\n        require(msg.value >= regFee, \"Registration Failed, Insufficient Fee\");\n        require(!isProsumer[msg.sender], \"You are already a Prosumer in the Network\");\n        require(!isRequested(), \"You have already requested for Registration\");\n\n        uint256 digitCheck = _aadharNo;\n        uint256 digits = 0;\n\n        while (digitCheck != 0) {\n            digitCheck /= 10;\n            digits++;\n        }\n\n        require(digits == 12, \"Enter a 12 digit Aadhar No.\");\n\n        //Create a prosumer object\n        prosumer memory _prosumer = prosumer({\n            _prosumerID: 0,\n            _address: msg.sender,\n            _aadharId: _aadharNo,\n            _approved: false,\n            _suspended: false,\n            _energyUnitPriceUSD: 0,\n            _energyUnitPriceMatic: 0,\n            _stakedEnergyBalance: 0\n        });\n\n        //Push the prosumer object to unApprovedProsumerArray\n        unApprovedProsumers.push(_prosumer);\n    }\n\n    function raiseComplain(uint256 _prosumerId, string memory _complainBody) public {\n        require(isProsumer[_msgSender()], \"You not a Prosumer\");\n        require(isProsumer[prosumerAddress[_prosumerId]], \"Accused not a Prosumer\");\n        require(\n            !suspended[prosumerAddress[_prosumerId]][_msgSender()],\n            \"Accused Prosumer is Suspended\"\n        );\n        require(!suspended[_msgSender()][prosumerAddress[_prosumerId]], \"You are Suspended\");\n        require(\n            !disapproved[prosumerAddress[_prosumerId]][_msgSender()],\n            \"Prosumer is Disapproved\"\n        );\n        require(!disapproved[_msgSender()][prosumerAddress[_prosumerId]], \"You are Disapproved\");\n\n        Complain memory _complain = Complain({\n            _complainID: complains.length + 1,\n            _complainant: prosumerID[_msgSender()],\n            _accused: _prosumerId,\n            _complain: _complainBody,\n            _resolved: false\n        });\n\n        if (complains.length < maxComplains) {\n            complains.push(_complain);\n        } else {\n            complains[complainCount % maxComplains] = _complain;\n        }\n\n        if (complainCount < maxComplains) {\n            complainCount++;\n        }\n    }\n\n    /***************Owner Functions***********************/\n\n    //--> 1. Set Registration Fee\n\n    function setRegFee(uint256 _regFee) public onlyOwner {\n        regFee = _regFee;\n    }\n\n    //--> 2. Verify Details of Unapproved Prosumer\n\n    //-->2.1 Internal Function\n\n    function deleteElementFrom_UnApprovedProsumers(\n        uint256 _unApprovedProsumerID\n    ) private onlyOwner {\n        require(\n            _unApprovedProsumerID < unApprovedProsumers.length,\n            \"Invalid unapprovedProsumer Index\"\n        );\n\n        for (uint256 i = _unApprovedProsumerID; i < unApprovedProsumers.length - 1; i++) {\n            unApprovedProsumers[i] = unApprovedProsumers[i + 1];\n        }\n        unApprovedProsumers.pop();\n    }\n\n    /*-----------------------------------------------------------------------------------------------*/\n\n    //-->2.2 Show all Approved or Unapproved Prosumer\n\n    function show_Unapproved_Prosumers() public view onlyOwner returns (prosumer[] memory) {\n        return unApprovedProsumers;\n    }\n\n    function show_Approved_Prosumers() public view returns (prosumer[] memory) {\n        //Public Function anybody can call\n        return ApprovedProsumers;\n    }\n\n    //-->2.3 Approval Status [Owner Specific]\n\n    function showApprovalStatus_OwnerSpecific(\n        address _unapprovedProsumerAddress\n    ) public view onlyOwner returns (string memory) {\n        if (approved[_unapprovedProsumerAddress][_msgSender()]) {\n            return (\"Prosumer Approved\");\n        } else if (disapproved[_unapprovedProsumerAddress][_msgSender()]) {\n            return (\"Prosumer Disapproved\");\n        } else {\n            return (\"Prosumer Not Verified Yet\");\n        }\n    }\n\n    /*** Admission of Prosumer ***/\n\n    //--> 3. Approve Prosumer\n\n    function approveProsumer_OwnerSpecific(uint256 _unApprovedProsumerID) public onlyOwner {\n        require(\n            _unApprovedProsumerID < unApprovedProsumers.length,\n            \"Invalid Unapproved Prosumer ID\"\n        );\n        require(\n            approved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()] == false,\n            \"Prosumer Already approved by you\"\n        );\n\n        approved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()] = true;\n\n        //If disapproved earlier then wants to approve\n        if (disapproved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()]) {\n            disapproved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()] = false;\n            disapprovalCount[unApprovedProsumers[_unApprovedProsumerID]._address]--;\n        }\n\n        uint256 getApprovalCount = approvalCount[\n            unApprovedProsumers[_unApprovedProsumerID]._address\n        ]++;\n\n        //check if approval > required\n        if (getApprovalCount > required) {\n            //if yes then remove him from unapprove array and add him to approved prosumer array\n            unApprovedProsumers[_unApprovedProsumerID]._approved = true; //Set approved Flag = true\n            unApprovedProsumers[_unApprovedProsumerID]._prosumerID = ApprovedProsumers.length + 1; //Set Prosumer ID\n            isProsumer[unApprovedProsumers[_unApprovedProsumerID]._address] = true;\n            ApprovedProsumers.push(unApprovedProsumers[_unApprovedProsumerID]);\n            deleteElementFrom_UnApprovedProsumers(_unApprovedProsumerID);\n\n            /*Store the prosumers in the Maps*/\n            prosumerAddress[ApprovedProsumers.length] = ApprovedProsumers[\n                ApprovedProsumers.length - 1\n            ]._address;\n            prosumerID[ApprovedProsumers[ApprovedProsumers.length - 1]._address] = ApprovedProsumers\n                .length;\n        }\n    }\n\n    //--> 4. Disapprove Prosumer\n    function DisApproveProsumer_OwnerSpecific(uint256 _unApprovedProsumerID) public onlyOwner {\n        require(\n            _unApprovedProsumerID < unApprovedProsumers.length,\n            \"Invalid Unapproved Prosumer ID\"\n        );\n        require(\n            disapproved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()] == false,\n            \"Prosumer Already disapproved by you\"\n        );\n\n        disapproved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()] = true;\n\n        //If approved earlier then disapprove\n        if (disapproved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()]) {\n            approved[unApprovedProsumers[_unApprovedProsumerID]._address][_msgSender()] = false;\n            approvalCount[unApprovedProsumers[_unApprovedProsumerID]._address]--;\n        }\n\n        uint256 getDisApprovalCount = disapprovalCount[\n            unApprovedProsumers[_unApprovedProsumerID]._address\n        ]++;\n\n        //check if disapproval > required\n        if (getDisApprovalCount > required) {\n            //if yes then remove him from unapprove array & don't store in approved array\n            deleteElementFrom_UnApprovedProsumers(_unApprovedProsumerID);\n            delete disapprovalCount[unApprovedProsumers[_unApprovedProsumerID]._address];\n            delete approvalCount[unApprovedProsumers[_unApprovedProsumerID]._address];\n        }\n    }\n\n    /*** Suspension of Prosumer ***/\n\n    //--> 5. Suspend Prosumer\n    function suspendProsumer(uint256 _prosumerId, uint256 _complainId) public onlyOwner {\n        address getProsumerAddress = prosumerAddress[_prosumerId];\n        require(isProsumer[getProsumerAddress], \"Not a Prosumer\");\n        require(!suspended[getProsumerAddress][_msgSender()], \"Already Suspended\");\n\n        suspended[getProsumerAddress][_msgSender()] = true;\n\n        //If unsuspended earlier then suspend\n        if (unSuspended[getProsumerAddress][_msgSender()]) {\n            unSuspended[getProsumerAddress][_msgSender()] = false;\n            unSuspensionCount[getProsumerAddress]--;\n        }\n\n        uint256 getSuspensionCount = suspensionCount[getProsumerAddress]++;\n\n        //check if suspension > required\n        if (getSuspensionCount > required) {\n            //if yes then remove him from unapprove array & don't store in approved array\n            delete suspensionCount[getProsumerAddress];\n            ApprovedProsumers[_prosumerId - 1]._suspended = true;\n            complains[_complainId - 1]._resolved = true;\n        }\n    }\n\n    //--> 6. Unsuspend Prosumer\n    function unSuspendProsumer(uint256 _prosumerId, uint256 _complainId) public onlyOwner {\n        require(isProsumer[prosumerAddress[_prosumerId]], \"Not a Prosumer\");\n        require(!unSuspended[prosumerAddress[_prosumerId]][_msgSender()], \"Already Unsuspended\");\n\n        address prosumerToUnsuspend = prosumerAddress[_prosumerId];\n\n        unSuspended[prosumerToUnsuspend][_msgSender()] = true;\n\n        // If suspended earlier then unsuspend\n        if (suspended[prosumerToUnsuspend][_msgSender()]) {\n            suspended[prosumerToUnsuspend][_msgSender()] = false;\n            suspensionCount[prosumerToUnsuspend]--;\n        }\n\n        uint256 getUnSuspensionCount = unSuspensionCount[prosumerToUnsuspend]++;\n\n        // Check if unsuspension > required\n        if (getUnSuspensionCount > required) {\n            // If yes, then remove him from unapprove array & don't store in the approved array\n            delete unSuspensionCount[prosumerToUnsuspend];\n            delete suspensionCount[prosumerToUnsuspend];\n            ApprovedProsumers[_prosumerId - 1]._suspended = false;\n            complains[_complainId - 1]._resolved = true;\n        }\n    }\n\n    //-->6.3. Witdhraw Funds (Pending , send funds equally to all prosumer)  //Can only be called when Transaction array will be zero.\n    function withdrawFees() public onlyOwner {\n        uint256 euqiBalance = address(this).balance / owners.length;\n\n        for (uint256 i = 0; i < owners.length; i++) {\n            (bool callSuccess, ) = payable(owners[i]).call{value: euqiBalance}(\"\");\n            require(callSuccess, \"Call Failed\");\n        }\n    }\n\n    //6.4. Transfer Ownership\n    function transferOwnership(address newOwner) public onlyOwner {\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (owners[i] == _msgSender()) {\n                owners[i] = newOwner;\n                break;\n            }\n        }\n    }\n\n    modifier onlyOwner() {\n        require(isOwner[_msgSender()], \"Not Owner\");\n        _;\n    }\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\ncontract PriceConverter {\r\n    AggregatorV3Interface internal priceFeed;\r\n\r\n    /**\r\n     * Network: Polygon Mumbai\r\n     * Aggregator: MATIC/USD\r\n     * Address: 0xd0D5e3DB44DE05E9F294BB0a3bEEaF030DE24Ada\r\n     */\r\n    constructor() {\r\n        priceFeed = AggregatorV3Interface(0xd0D5e3DB44DE05E9F294BB0a3bEEaF030DE24Ada);\r\n    }\r\n\r\n    /**\r\n     * Returns the latest price\r\n     */\r\n    function getLatestPrice() public view returns (int) {\r\n        (\r\n            ,\r\n            /*uint80 roundID*/ int price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\r\n            ,\r\n            ,\r\n\r\n        ) = priceFeed.latestRoundData();\r\n        return price;\r\n    }\r\n}\r\n\r\n// $ 1.14973259\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}